{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "slug",
  "type": "registry:item",
  "title": "Slug Field",
  "description": "Copy of original payload slug field to allow code customization.",
  "files": [
    {
      "path": "registry/fields/slug/field.ts",
      "content": "import type { TextFieldClientProps, RowField, TextField } from 'payload'\r\n\r\nimport { generateSlug } from './generateSlug'\r\n\r\ntype SlugFieldArgs = {\r\n  /**\r\n   * Override for the `generateSlug` checkbox field name.\r\n   * @default 'generateSlug'\r\n   */\r\n  checkboxName?: string\r\n  /**\r\n   * The name of the field to generate the slug from, when applicable.\r\n   * @default 'title'\r\n   */\r\n  fieldToUse?: string\r\n  /**\r\n   * Enable localization for the slug field.\r\n   */\r\n  localized?: TextField['localized']\r\n  /**\r\n   * Override for the `slug` field name.\r\n   * @default 'slug'\r\n   */\r\n  name?: string\r\n  /**\r\n   * A function used to override te fields at a granular level.\r\n   * Passes the row field to you to manipulate beyond the exposed options.\r\n   * @example\r\n   * ```ts\r\n   * slugField({\r\n   *   overrides: (field) => {\r\n   *     field.fields[1].label = 'Custom Slug Label'\r\n   *     return field\r\n   *   }\r\n   * })\r\n   * ```\r\n   */\r\n  overrides?: (field: RowField) => RowField\r\n  position?: 'sidebar'\r\n  /**\r\n   * Whether or not the `slug` field is required.\r\n   * @default true\r\n   */\r\n  required?: TextField['required']\r\n}\r\n\r\ntype SlugField = (args?: SlugFieldArgs) => RowField\r\n\r\nexport type SlugFieldClientProps = {} & Pick<SlugFieldArgs, 'fieldToUse'>\r\n\r\nexport type SlugFieldProps = SlugFieldClientProps & TextFieldClientProps\r\n\r\n/**\r\n * A slug is a unique, indexed, URL-friendly string that identifies a particular document, often used to construct the URL of a webpage.\r\n * The `slug` field auto-generates its value based on another field, e.g. \"My Title\" â†’ \"my-title\".\r\n *\r\n * The slug should continue to be generated through:\r\n * 1. The `create` operation, unless the user has modified the slug manually\r\n * 2. The `update` operation, if:\r\n *   a. Autosave is _not_ enabled and there is no slug\r\n *   b. Autosave _is_ enabled, the doc is unpublished, and the user has not modified the slug manually\r\n *\r\n * The slug should stabilize after all above criteria have been met, because the URL is typically derived from the slug.\r\n * This is to protect modifying potentially live URLs, breaking links, etc. without explicit intent.\r\n *\r\n * You can change the slug generation logic by modifying the `slugify` function in `src/fields/slug/slugify.ts`.\r\n *\r\n * @experimental This field is experimental and may change or be removed in the future. Use at your own risk.\r\n */\r\nexport const slugField: SlugField = ({\r\n  name: fieldName = 'slug',\r\n  checkboxName = 'generateSlug',\r\n  fieldToUse = 'title',\r\n  localized,\r\n  overrides,\r\n  position = 'sidebar',\r\n  required = true,\r\n} = {}) => {\r\n  const baseField: RowField = {\r\n    type: 'row',\r\n    admin: {\r\n      position,\r\n    },\r\n    fields: [\r\n      {\r\n        name: checkboxName,\r\n        type: 'checkbox',\r\n        admin: {\r\n          description:\r\n            'When enabled, the slug will auto-generate from the title field on save and autosave.',\r\n          disableBulkEdit: true,\r\n          disableGroupBy: true,\r\n          disableListColumn: true,\r\n          disableListFilter: true,\r\n          hidden: true,\r\n        },\r\n        defaultValue: true,\r\n        hooks: {\r\n          beforeChange: [generateSlug({ fieldName, fieldToUse })],\r\n        },\r\n        localized,\r\n      },\r\n      {\r\n        name: fieldName,\r\n        type: 'text',\r\n        admin: {\r\n          components: {\r\n            Field: {\r\n              clientProps: {\r\n                fieldToUse,\r\n              } satisfies SlugFieldClientProps,\r\n              path: '@/fields/slug#SlugField',\r\n            },\r\n          },\r\n          width: '100%',\r\n        },\r\n        index: true,\r\n        localized,\r\n        required,\r\n        unique: true,\r\n      },\r\n    ],\r\n  }\r\n\r\n  if (typeof overrides === 'function') {\r\n    return overrides(baseField)\r\n  }\r\n\r\n  return baseField\r\n}\r\n",
      "type": "registry:file",
      "target": "~/src/fields/slug/field.ts"
    },
    {
      "path": "registry/fields/slug/index.tsx",
      "content": "'use client'\r\n\r\nimport React, { useCallback, useState } from 'react'\r\nimport { Button, useForm, useField, FieldLabel, TextInput } from '@payloadcms/ui'\r\nimport './style.scss'\r\nimport { SlugFieldProps } from './field'\r\nimport { slugify } from './slugify'\r\n\r\n/**\r\n * @experimental This component is experimental and may change or be removed in the future. Use at your own risk.\r\n */\r\nexport const SlugField: React.FC<SlugFieldProps> = ({\r\n  field,\r\n  fieldToUse,\r\n  path,\r\n  readOnly: readOnlyFromProps,\r\n}) => {\r\n  const { label } = field\r\n\r\n  const { setValue, value } = useField<string>({ path: path || field.name })\r\n\r\n  const { getDataByPath } = useForm()\r\n\r\n  const [isLocked, setIsLocked] = useState(true)\r\n\r\n  const handleGenerate = useCallback(\r\n    (e: React.MouseEvent<Element>) => {\r\n      e.preventDefault()\r\n\r\n      const targetFieldValue = getDataByPath(fieldToUse || 'title')\r\n\r\n      if (targetFieldValue) {\r\n        const formattedSlug = slugify(targetFieldValue as string)\r\n\r\n        if (value !== formattedSlug) {\r\n          setValue(formattedSlug)\r\n        }\r\n      } else {\r\n        if (value !== '') {\r\n          setValue('')\r\n        }\r\n      }\r\n    },\r\n    [setValue, value, fieldToUse, getDataByPath],\r\n  )\r\n\r\n  const toggleLock = useCallback((e: React.MouseEvent<Element>) => {\r\n    e.preventDefault()\r\n    setIsLocked((prev) => !prev)\r\n  }, [])\r\n\r\n  return (\r\n    <div className=\"field-type slug-field-component\">\r\n      <div className=\"label-wrapper\">\r\n        <FieldLabel htmlFor={`field-${path}`} label={label} />\r\n        {!isLocked && (\r\n          <Button buttonStyle=\"none\" className=\"lock-button\" onClick={handleGenerate}>\r\n            Generate\r\n          </Button>\r\n        )}\r\n        <Button buttonStyle=\"none\" className=\"lock-button\" onClick={toggleLock}>\r\n          {isLocked ? 'Unlock' : 'Lock'}\r\n        </Button>\r\n      </div>\r\n      <TextInput\r\n        onChange={setValue}\r\n        path={path || field.name}\r\n        readOnly={Boolean(readOnlyFromProps || isLocked)}\r\n        value={value}\r\n      />\r\n    </div>\r\n  )\r\n}\r\n",
      "type": "registry:file",
      "target": "~/src/fields/slug/index.tsx"
    },
    {
      "path": "registry/fields/slug/countVersions.ts",
      "content": "import type {\r\n  CollectionSlug,\r\n  DefaultDocumentIDType,\r\n  GlobalSlug,\r\n  PayloadRequest,\r\n  Where,\r\n} from 'payload'\r\n\r\n/**\r\n * This is a cross-entity way to count the number of versions for any given document.\r\n * It will work for both collections and globals.\r\n * @returns number of versions\r\n */\r\nexport const countVersions = async (args: {\r\n  collectionSlug?: CollectionSlug\r\n  globalSlug?: GlobalSlug\r\n  parentID?: DefaultDocumentIDType\r\n  req: PayloadRequest\r\n}): Promise<number> => {\r\n  const { collectionSlug, globalSlug, parentID, req } = args\r\n\r\n  let countFn\r\n\r\n  const where: Where = {\r\n    parent: {\r\n      equals: parentID,\r\n    },\r\n  }\r\n\r\n  if (collectionSlug) {\r\n    countFn = () =>\r\n      req.payload.countVersions({\r\n        collection: collectionSlug,\r\n        depth: 0,\r\n        where,\r\n      })\r\n  }\r\n\r\n  if (globalSlug) {\r\n    countFn = () =>\r\n      req.payload.countGlobalVersions({\r\n        depth: 0,\r\n        global: globalSlug,\r\n        where,\r\n      })\r\n  }\r\n\r\n  const res = countFn ? (await countFn()?.then((res) => res.totalDocs || 0)) || 0 : 0\r\n\r\n  return res\r\n}\r\n",
      "type": "registry:file",
      "target": "~/src/fields/slug/countVersions.ts"
    },
    {
      "path": "registry/fields/slug/generateSlug.ts",
      "content": "import type { FieldHook } from 'payload'\r\n\r\nimport { slugify } from './slugify'\r\nimport { countVersions } from './countVersions'\r\n\r\ntype HookArgs = {\r\n  /**\r\n   * Current field name for the slug. Defaults to `slug`.\r\n   */\r\n  fieldName?: string\r\n  fieldToUse: string\r\n}\r\n\r\n/**\r\n * This is a `BeforeChange` field hook used to auto-generate the `slug` field.\r\n * See `slugField` for more details.\r\n */\r\nexport const generateSlug =\r\n  ({ fieldName = 'slug', fieldToUse }: HookArgs): FieldHook =>\r\n  async (args) => {\r\n    const { collection, data, global, operation, originalDoc, req, value: isChecked } = args\r\n\r\n    // Ensure user-defined slugs are not overwritten during create\r\n    // Use a generic falsy check here to include empty strings\r\n    if (operation === 'create') {\r\n      if (data) {\r\n        data[fieldName] = slugify(data?.[fieldName] || data?.[fieldToUse])\r\n      }\r\n\r\n      return Boolean(!data?.[fieldName])\r\n    }\r\n\r\n    if (operation === 'update') {\r\n      // Early return to avoid additional processing\r\n      if (!isChecked) {\r\n        return false\r\n      }\r\n\r\n      const autosaveEnabled = Boolean(\r\n        (typeof collection?.versions?.drafts === 'object' &&\r\n          collection?.versions?.drafts.autosave) ||\r\n          (typeof global?.versions?.drafts === 'object' && global?.versions?.drafts.autosave),\r\n      )\r\n\r\n      if (!autosaveEnabled) {\r\n        // We can generate the slug at this point\r\n        if (data) {\r\n          data[fieldName] = slugify(data?.[fieldToUse])\r\n        }\r\n\r\n        return Boolean(!data?.[fieldName])\r\n      } else {\r\n        // If we're publishing, we can avoid querying as we can safely assume we've exceeded the version threshold (2)\r\n        const isPublishing = data?._status === 'published'\r\n\r\n        // Ensure the user can take over the generated slug themselves without it ever being overridden back\r\n        const userOverride = data?.[fieldName] !== originalDoc?.[fieldName]\r\n\r\n        if (!userOverride) {\r\n          if (data) {\r\n            // If the fallback is an empty string, we want the slug to return to `null`\r\n            // This will ensure that live preview conditions continue to run as expected\r\n            data[fieldName] = data?.[fieldToUse] ? slugify(data[fieldToUse]) : null\r\n          }\r\n        }\r\n\r\n        if (isPublishing || userOverride) {\r\n          return false\r\n        }\r\n\r\n        // Important: ensure `countVersions` is not called unnecessarily often\r\n        // That is why this is buried beneath all these conditions\r\n        const versionCount = await countVersions({\r\n          collectionSlug: collection?.slug,\r\n          globalSlug: global?.slug,\r\n          parentID: originalDoc?.id,\r\n          req: args.req,\r\n        })\r\n\r\n        if (versionCount <= 2) {\r\n          return true\r\n        } else {\r\n          return false\r\n        }\r\n      }\r\n    }\r\n  }\r\n",
      "type": "registry:file",
      "target": "~/src/fields/slug/generateSlug.ts"
    },
    {
      "path": "registry/fields/slug/slugify.ts",
      "content": "/**\r\n * This is main slugify function used in the slug field.\r\n * You can change its behavior as needed.\r\n * @returns slugified string\r\n */\r\nexport const slugify = (val?: string) =>\r\n  val\r\n    ?.replace(/ /g, '-')\r\n    .replace(/[^\\w-]+/g, '')\r\n    .toLowerCase()\r\n",
      "type": "registry:file",
      "target": "~/src/fields/slug/slugify.ts"
    },
    {
      "path": "registry/fields/slug/style.scss",
      "content": ".slug-field-component {\r\n    width: 100%;\r\n\r\n    .label-wrapper {\r\n      display: flex;\r\n      justify-content: space-between;\r\n      align-items: center;\r\n      gap: calc(var(--base) / 2);\r\n    }\r\n\r\n    .lock-button {\r\n      margin: 0;\r\n      padding-bottom: 0.3125rem;\r\n    }\r\n  }",
      "type": "registry:file",
      "target": "~/src/fields/slug/style.scss"
    }
  ]
}