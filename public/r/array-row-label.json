{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "array-row-label",
  "type": "registry:item",
  "title": "Custom Array Row Label",
  "description": "A custom array row label component for PayloadCMS.",
  "files": [
    {
      "path": "registry/components/array-row-label/utility.ts",
      "content": "import { ArrayRowLabelArgs } from './types'\r\n\r\n/**\r\n * Utility function to create a custom row label configuration for array fields.\r\n *\r\n * Usage:\r\n * ```ts\r\n * import { customRowLabel } from '@/components/array-row-label/utility'\r\n * \r\n * ...\r\n *  {\r\n      name: 'testArray',\r\n      type: 'array',\r\n      fields: [\r\n        {\r\n          name: 'title',\r\n          type: 'text',\r\n          required: true,\r\n        },\r\n      ],\r\n      admin: {\r\n        // Custom row label configuration\r\n        ...customRowLabel({ fieldToUse: 'title' }),\r\n      },\r\n    },\r\n * \r\n * ```\r\n */\r\nexport const customRowLabel = ({\r\n  fieldToUse,\r\n  template = false,\r\n  fallbackLabel,\r\n}: ArrayRowLabelArgs) => {\r\n  return {\r\n    components: {\r\n      RowLabel: {\r\n        path: '@/components/array-row-label',\r\n        clientProps: {\r\n          fieldToUse,\r\n          template: Boolean(template),\r\n          fallbackLabel: fallbackLabel,\r\n        },\r\n      },\r\n    },\r\n  }\r\n}\r\n",
      "type": "registry:file",
      "target": "~/src/components/array-row-label/utility.ts"
    },
    {
      "path": "registry/components/array-row-label/index.tsx",
      "content": "'use client'\r\nimport { useRowLabel } from '@payloadcms/ui'\r\nimport { ArrayRowLabelArgs } from './types'\r\nimport { useMemo } from 'react'\r\n\r\n/**\r\n * Helper function to get nested value from an object using dot notation\r\n * e.g. getNestedValue(obj, 'nested.fieldName')\r\n */\r\nconst getNestedValue = (obj: unknown, path: string): unknown => {\r\n  return path.split('.').reduce((acc, part) => {\r\n    if (acc && typeof acc === 'object' && acc !== null && part in acc) {\r\n      return (acc as Record<string, unknown>)[part]\r\n    }\r\n    return undefined\r\n  }, obj)\r\n}\r\n\r\n/**\r\n * Helper function to check if all field variables in a template are empty\r\n */\r\nconst hasEmptyFieldValues = (template: string, data: unknown): boolean => {\r\n  const fieldMatches = template.match(/{{\\s*([\\w.]+)\\s*}}/g)\r\n\r\n  if (!fieldMatches) {\r\n    return false\r\n  }\r\n\r\n  // Check if all field variables (excluding 'index') are empty\r\n  return fieldMatches.every((match) => {\r\n    const fieldPath = match.replace(/{{\\s*|\\s*}}/g, '')\r\n\r\n    // Skip 'index' as it's always populated\r\n    if (fieldPath === 'index') {\r\n      return false\r\n    }\r\n\r\n    const value = getNestedValue(data, fieldPath)\r\n    return !value || (typeof value === 'string' && value.trim() === '')\r\n  })\r\n}\r\n\r\n/**\r\n * Helper function to process template strings with variable replacement\r\n */\r\nconst processTemplate = (template: string, data: unknown, rowNumber?: number): string => {\r\n  let result = template.replace(/{{\\s*index\\s*}}/g, String(rowNumber || 0))\r\n\r\n  result = result.replace(/{{\\s*([\\w.]+)\\s*}}/g, (_, fieldPath) => {\r\n    const value = getNestedValue(data, fieldPath)\r\n    if (typeof value === 'string' || typeof value === 'number') {\r\n      return String(value)\r\n    }\r\n    return ''\r\n  })\r\n\r\n  return result\r\n}\r\n\r\nconst ArrayCustomLabel: React.FC<ArrayRowLabelArgs> = ({\r\n  fieldToUse,\r\n  template = false,\r\n  fallbackLabel = 'Item {{index}}',\r\n}) => {\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  const { data, rowNumber } = useRowLabel<any>()\r\n\r\n  const customLabel = useMemo(() => {\r\n    let labelValue = ''\r\n    let shouldUseFallback = false\r\n\r\n    if (!template) {\r\n      // Simple field mode\r\n      const value = getNestedValue(data, fieldToUse)\r\n      if (typeof value === 'string' || typeof value === 'number') {\r\n        labelValue = String(value).trim()\r\n      }\r\n      shouldUseFallback = !labelValue\r\n    } else {\r\n      // Template mode - check if all field values are empty\r\n      shouldUseFallback = hasEmptyFieldValues(fieldToUse, data)\r\n\r\n      if (!shouldUseFallback) {\r\n        labelValue = processTemplate(fieldToUse, data, rowNumber).trim()\r\n      }\r\n    }\r\n\r\n    // Use fallback if needed\r\n    if (shouldUseFallback) {\r\n      labelValue = processTemplate(fallbackLabel, data, rowNumber)\r\n    }\r\n\r\n    return labelValue\r\n  }, [data, fieldToUse, template, fallbackLabel, rowNumber])\r\n\r\n  return <>{customLabel}</>\r\n}\r\n\r\nexport default ArrayCustomLabel\r\n",
      "type": "registry:file",
      "target": "~/src/components/array-row-label/index.tsx"
    },
    {
      "path": "registry/components/array-row-label/types.ts",
      "content": "export type ArrayRowLabelArgs = {\r\n  /**\r\n   * The field in the array item to use for the label\r\n   * You can use dot notation for nested fields (e.g. 'nested.fieldName')\r\n   *\r\n   * And you can use {{variable}} syntax to include other values (e.g. 'Item {{index}} - {{fieldName}}')\r\n   * Pass `true` to the template option to enable this feature\r\n   */\r\n  fieldToUse: string\r\n  /**\r\n   * Whether to treat the fieldToUse as a template string\r\n   * Enables the use of {{variable}} syntax\r\n   *\r\n   * You can also use this varibles in template:\r\n   * - {{index}} - The current index of the row (starting from 0)\r\n   *\r\n   * Pass `true` to the template option to enable this feature\r\n   * @default false\r\n   */\r\n  template?: boolean\r\n  /**\r\n   *  Fallback label if the specified field is not found or is empty\r\n   *  @default 'Item {{index}}'\r\n   */\r\n  fallbackLabel?: string\r\n}\r\n",
      "type": "registry:file",
      "target": "~/src/components/array-row-label/types.ts"
    }
  ]
}